""" This set of functions is primarily used for photometery."""
from config import Configuration
from libraries.utils import Utils
from photutils import CircularAperture
from photutils import CircularAnnulus
from photutils import aperture_photometry
from astropy.wcs import WCS
import numpy as np
import pandas as pd
import warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)
warnings.filterwarnings("ignore", category=Warning)


class Photometry:

    @staticmethod
    def single_frame_aper(img, master_list, header, stars_to_phot=-1, flux_only='N',
                          bkg_sub='global', offset='N', diff_flux_convert='N', master_frame='N'):
        """" This function will perform aperture photometry on a single frame.

        :parameter img - The image where photometry will be performed
        :parameter master_list - A data frame with the relevant TIC information from the TIC query
        :parameter header - The image header file
        :parameter stars_to_phot - The number of stars you want photometry for (this can be used to check the code)
        :parameter flux_only - Y/N if you only want the flux to be generated by the code
        :parameter bkg_sub - global/local/diff if you want to subtract the local background,
                the median image background, or if the frame is from a differenced image
        :parameter offset - Y/N if you want to add an offset based on the master list flux values
        :parameter diff_flux_convert - Y/N if you want to convert the differenced flux to magnitude
        :parameter master_frame - Y/N if the image you are differencing is the master frame

        :return star_list - The star_list data frame is returned with the flux/mag values and errors included
        """
        # make a copy of the master data frame
        if stars_to_phot == -1:
            if master_frame == 'N':
                stars_for_phot = master_list.copy().reset_index(drop=True)
            else:
                star_list = master_list.copy().reset_index(drop=True)
        else:
            stars_for_phot = master_list[0:stars_to_phot].copy().reset_index(drop=True)

        if master_frame == 'N':
            star_list = pd.merge(stars_for_phot, master_list[['TICID', 'mag', 'flux', 'flux_err']],
                                 on='TICID', how='left', suffixes=['', '_master'])

        # convert the ra & dec positions to x & y positions based on the image header
        w = WCS(header)
        ra = star_list.ra.to_numpy()
        dec = star_list.dec.to_numpy()

        # convert to x, y
        x, y = w.all_world2pix(ra, dec, 0)
        positions = (x, y)

        # add the x/y to the star data frame
        star_list['x'] = x
        star_list['y'] = y

        # run aperture photometry
        # set up the star aperture and sky annuli
        aperture = CircularAperture(positions, r=Configuration.APER_SIZE)
        annulus_aperture = CircularAnnulus(positions, r_in=Configuration.ANNULI_INNER, r_out=Configuration.ANNULI_OUTER)
        apers = [aperture, annulus_aperture]

        # run the photometry to get the data table
        phot_table = aperture_photometry(img, apers, method='exact')

        # extract the sky background for each annuli
        sky = phot_table['aperture_sum_1'] / annulus_aperture.area
        if bkg_sub == 'local':
            bkg = sky * aperture.area
        elif bkg_sub == 'global':
            bkg = np.median(img) * aperture.area
        else:
            bkg = 0

        # subtract the sky background to get the stellar flux and sqrt of total flux to get the photometric error
        star_list['flux'] = np.array(phot_table['aperture_sum_0'] - bkg)
        star_list['flux_err'] = np.array(np.sqrt(np.abs(phot_table['aperture_sum_0'])))

        if diff_flux_convert == 'Y':
            # convert to magnitude
            star_list['mag'] = star_list.apply(lambda x: 25. - 2.5 * np.log10(x.flux + x.flux_master), axis=1)
            star_list['mag_err'] = star_list.apply(lambda x: (2.5 / np.log(10.)) *
                                                             (np.sqrt(x.flux_err ** 2 + x.flux_err_master ** 2) /
                                                              (x.flux + x.flux_master)), axis=1)

        if offset == 'Y':
            # determine the median offset of the frame (then apply to all stars)
            off = np.median(star_list[star_list['mag'] < Configuration.MG_CLP]['mag'] -
                            star_list[star_list['mag'] < Configuration.MG_CLP]['mag_master'])

            # apply to the full data set
            star_list['clean'] = star_list.apply(lambda x: x.mag - off, axis=1)

        if flux_only == 'N':
            # convert to magnitude
            star_list['mag'] = 25. - 2.5 * np.log10(star_list['flux'].to_numpy())
            star_list['mag_err'] = (2.5 / np.log(10.)) * (star_list['flux_err'].to_numpy() /
                                                          star_list['flux'].to_numpy())

        return star_list

    @staticmethod
    def read_in_lightcurves(directory, ticid):
        """ This program will read all of the light curves in a given directory into a single data frame.

        :parameter directory - The directory with the light curves to read in
        :parameter ticid - The list of TICIDs to read in

        :return lc_df - The light curve data frame, with the columns as time, and rows as light curves"""

        filenames = [directory + str(x) + "_" + Configuration.SECTOR + "_" + Configuration.CAMERA +
                     "_" + Configuration.CCD + ".lc" for x in ticid]

        Utils.log("Importing light curve data for " + str(len(ticid)) + " trend stars."
                  , "info", Configuration.LOG_SCREEN)

        lc_data = np.array([np.loadtxt(f, usecols=(1,)) for f in filenames])

        return lc_data
